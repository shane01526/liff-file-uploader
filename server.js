const express = require('express');
const cors = require('cors');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const axios = require('axios');

// ËºâÂÖ•Áí∞Â¢ÉËÆäÊï∏
if (fs.existsSync('.env')) {
  require('dotenv').config();
}

const app = express();
const PORT = process.env.PORT || 10000;

console.log('üöÄ ÂïüÂãï‰º∫ÊúçÂô®...');
console.log('üìç Port:', PORT);
console.log('üåç Environment:', process.env.NODE_ENV || 'development');

// Âü∫Êú¨‰∏≠‰ªãËªüÈ´î
app.use(cors({
  origin: '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'x-line-userid', 'x-line-signature']
}));

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Ë´ãÊ±ÇÊó•Ë™å
app.use((req, res, next) => {
  console.log(`üìù ${new Date().toISOString()} - ${req.method} ${req.url}`);
  next();
});

// Âª∫Á´ã uploads Ë≥áÊñôÂ§æ
const uploadDir = path.join(__dirname, 'uploads');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
  console.log('üìÅ Âª∫Á´ã uploads Ë≥áÊñôÂ§æ:', uploadDir);
}

// Multer Ë®≠ÂÆö
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const uniqueName = `${timestamp}-${file.originalname}`;
    cb(null, uniqueName);
  }
});

const upload = multer({ 
  storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];
    const allowedExts = ['.pdf', '.doc', '.docx'];
    const fileExt = path.extname(file.originalname).toLowerCase();
    
    if (allowedTypes.includes(file.mimetype) || allowedExts.includes(fileExt)) {
      cb(null, true);
    } else {
      cb(new Error('‰∏çÊîØÊè¥ÁöÑÊ™îÊ°àÊ†ºÂºè'));
    }
  }
});

// ============= Êñ∞Â¢ûÔºöÊ®°Êì¨Áî®Êà∂ PostBack ÂäüËÉΩ =============

// Ê®°Êì¨Áî®Êà∂ÁôºÈÄÅ PostBack Âà∞Ëá™Â∑±ÁöÑ Webhook
async function simulateUserPostbackToWebhook(userId, downloadUrl, fileName, fileSize) {
  try {
    console.log('üé≠ Ê®°Êì¨Áî®Êà∂ÁôºÈÄÅ PostBack Ë®äÊÅØÂà∞ Webhook');
    
    // ÊßãÈÄ†Ê®°Êì¨ÁöÑ LINE Webhook ‰∫ã‰ª∂
    const mockWebhookEvent = {
      events: [
        {
          type: 'postback',
          mode: 'active',
          timestamp: Date.now(),
          source: {
            type: 'user',
            userId: userId
          },
          postback: {
            data: JSON.stringify({
              action: 'file_uploaded',
              fileName: fileName,
              downloadUrl: downloadUrl,
              fileSize: fileSize,
              uploadTime: new Date().toISOString(),
              source: 'file_upload_system'
            }),
            params: {}
          },
          replyToken: 'mock_reply_token_' + Date.now()
        }
      ],
      destination: process.env.LINE_BOT_USER_ID || 'mock_destination'
    };

    console.log('üì§ Ê®°Êì¨ Webhook ‰∫ã‰ª∂:', JSON.stringify(mockWebhookEvent, null, 2));
    
    // Áõ¥Êé•Ë™øÁî® Webhook ËôïÁêÜÂáΩÊï∏
    await processSimulatedWebhookEvent(mockWebhookEvent);
    
    return true;
  } catch (error) {
    console.error('‚ùå Ê®°Êì¨ PostBack Â§±Êïó:', error);
    return false;
  }
}

// ËôïÁêÜÊ®°Êì¨ÁöÑ Webhook ‰∫ã‰ª∂
async function processSimulatedWebhookEvent(webhookData) {
  try {
    console.log('üîÑ ËôïÁêÜÊ®°Êì¨ÁöÑ Webhook ‰∫ã‰ª∂');
    
    const events = webhookData.events || [];
    
    for (const event of events) {
      const userId = event.source.userId;
      
      if (event.type === 'postback') {
        console.log('üì® ËôïÁêÜÊ®°Êì¨ PostBack:', event.postback.data);
        
        const postbackData = JSON.parse(event.postback.data);
        
        switch (postbackData.action) {
          case 'file_uploaded':
            await handleUserFileUploadEvent(userId, postbackData);
            break;
            
          default:
            console.log('‚ùì Êú™Áü•ÁöÑÊ®°Êì¨ PostBack Âãï‰Ωú:', postbackData.action);
        }
      }
    }
    
  } catch (error) {
    console.error('‚ùå ËôïÁêÜÊ®°Êì¨ Webhook ‰∫ã‰ª∂Â§±Êïó:', error);
  }
}

// ËôïÁêÜÁî®Êà∂Ê™îÊ°à‰∏äÂÇ≥‰∫ã‰ª∂Ôºà‰Ω†ÁöÑÊ•≠ÂãôÈÇèËºØÔºâ
async function handleUserFileUploadEvent(userId, data) {
  try {
    console.log(`üë§ Ê®°Êì¨ÔºöÁî®Êà∂ ${userId} ‰∏äÂÇ≥‰∫ÜÊ™îÊ°à: ${data.fileName}`);
    console.log('üìä Ê™îÊ°àË≥áË®ä:', {
      fileName: data.fileName,
      fileSize: `${(data.fileSize / 1024 / 1024).toFixed(2)} MB`,
      downloadUrl: data.downloadUrl,
      uploadTime: data.uploadTime
    });
    
    // üéØ Âú®ÈÄôË£°Ê∑ªÂä†‰Ω†ÁöÑÊ•≠ÂãôÈÇèËºØ
    // ‰æãÂ¶ÇÔºöË®òÈåÑÂà∞Ë≥áÊñôÂ∫´„ÄÅÁôºÈÄÅÈÄöÁü•„ÄÅËß∏ÁôºÂÖ∂‰ªñÁ≥ªÁµ±Á≠â
    
    // Â¶ÇÊûúË®≠ÂÆö‰∫Ü LINE TokenÔºåÂõûÊáâÁµ¶Áî®Êà∂
    if (process.env.LINE_CHANNEL_ACCESS_TOKEN) {
      await sendLineMessage(userId, 
        `‚úÖ Êî∂Âà∞ÊÇ®‰∏äÂÇ≥ÁöÑÊ™îÊ°à„Äå${data.fileName}„Äç\n\n` +
        `üìä Ê™îÊ°àÂ§ßÂ∞è: ${(data.fileSize / 1024 / 1024).toFixed(2)} MB\n` +
        `üïê ‰∏äÂÇ≥ÊôÇÈñì: ${new Date(data.uploadTime).toLocaleString('zh-TW')}\n\n` +
        `ü§ñ Á≥ªÁµ±Ê≠£Âú®ËôïÁêÜÊÇ®ÁöÑÊ™îÊ°à...`
      );
      
      // Ê®°Êì¨ËôïÁêÜÂÆåÊàêÈÄöÁü•
      setTimeout(async () => {
        await sendLineMessage(userId, 
          `üéâ Ê™îÊ°à„Äå${data.fileName}„ÄçËôïÁêÜÂÆåÊàêÔºÅ\n\n` +
          `üì• ‰∏ãËºâÈÄ£Áµê: ${data.downloadUrl}`
        );
      }, 3000);
    }
    
  } catch (error) {
    console.error('‚ùå ËôïÁêÜÁî®Êà∂Ê™îÊ°à‰∏äÂÇ≥‰∫ã‰ª∂Â§±Êïó:', error);
  }
}

// ÁôºÈÄÅ LINE Ë®äÊÅØÁöÑËºîÂä©ÂáΩÊï∏
async function sendLineMessage(userId, message) {
  try {
    await axios.post('https://api.line.me/v2/bot/message/push', {
      to: userId,
      messages: [{ type: 'text', text: message }]
    }, {
      headers: {
        'Authorization': `Bearer ${process.env.LINE_CHANNEL_ACCESS_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
    console.log('üì§ LINE Ë®äÊÅØÂ∑≤ÁôºÈÄÅ');
  } catch (error) {
    console.error('‚ùå ÁôºÈÄÅ LINE Ë®äÊÅØÂ§±Êïó:', error.response?.data || error.message);
  }
}

// ============= ÂéüÊúâÁöÑ LINE Bot ÂäüËÉΩ =============

// LINE Bot Ë®äÊÅØÁôºÈÄÅÂáΩÊï∏ - ÊîØÊè¥ PostBack ÊåâÈàï
async function sendLineDownloadMessage(userId, fileName, downloadUrl, fileSize) {
  try {
    if (!process.env.LINE_CHANNEL_ACCESS_TOKEN) {
      console.warn('‚ö†Ô∏è LINE Token Êú™Ë®≠ÂÆö');
      return false;
    }

    // Âª∫Á´ãÂ∏∂Êúâ‰∏ãËºâÊåâÈàïÁöÑË®äÊÅØ
    const message = {
      type: 'template',
      altText: `‚úÖ ${fileName} ‰∏äÂÇ≥ÊàêÂäüÔºÅÈªûÊìä‰∏ãËºâÊ™îÊ°à`,
      template: {
        type: 'buttons',
        thumbnailImageUrl: 'https://i.imgur.com/8QmD2Kt.png',
        imageAspectRatio: 'rectangle',
        imageSize: 'cover',
        imageBackgroundColor: '#F5F3F0',
        title: 'üìÑ Ê™îÊ°à‰∏äÂÇ≥ÊàêÂäü',
        text: `Ê™îÊ°àÔºö${fileName.length > 30 ? fileName.substring(0, 30) + '...' : fileName}\nÂ§ßÂ∞èÔºö${(fileSize / 1024 / 1024).toFixed(2)} MB\nÊôÇÈñìÔºö${new Date().toLocaleString('zh-TW')}`,
        actions: [
          {
            type: 'uri',
            label: 'üì• ‰∏ãËºâÊ™îÊ°à',
            uri: downloadUrl
          },
          {
            type: 'postback',
            label: 'üìã Ë§áË£ΩÈÄ£Áµê',
            data: JSON.stringify({
              action: 'copy_link',
              url: downloadUrl,
              fileName: fileName
            }),
            displayText: 'Â∑≤Ë§áË£Ω‰∏ãËºâÈÄ£Áµê'
          },
          {
            type: 'postback',
            label: 'üóëÔ∏è Âà™Èô§Ê™îÊ°à',
            data: JSON.stringify({
              action: 'delete_file',
              fileName: fileName,
              confirm: true
            }),
            displayText: 'Á¢∫Ë™çÂà™Èô§Ê™îÊ°àÔºü'
          }
        ]
      }
    };

    const response = await axios.post('https://api.line.me/v2/bot/message/push', {
      to: userId,
      messages: [message]
    }, {
      headers: {
        'Authorization': `Bearer ${process.env.LINE_CHANNEL_ACCESS_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });

    console.log('‚úÖ LINE PostBack Ë®äÊÅØÁôºÈÄÅÊàêÂäü');
    return true;
  } catch (error) {
    console.error('‚ùå LINE Ë®äÊÅØÁôºÈÄÅÂ§±Êïó:', error.response?.data || error.message);
    return false;
  }
}

// Á∞°ÂñÆÊñáÂ≠óË®äÊÅØÁôºÈÄÅÔºàÂÇôÁî®Ôºâ
async function sendSimpleLineMessage(userId, text) {
  try {
    await axios.post('https://api.line.me/v2/bot/message/push', {
      to: userId,
      messages: [{ type: 'text', text: text }]
    }, {
      headers: {
        'Authorization': `Bearer ${process.env.LINE_CHANNEL_ACCESS_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });
  } catch (error) {
    console.error('‚ùå ÁôºÈÄÅÁ∞°ÂñÆË®äÊÅØÂ§±Êïó:', error.response?.data || error.message);
  }
}

// Ê™îÊ°àÂà™Èô§ËôïÁêÜ
async function handleFileDelete(userId, fileName) {
  try {
    const files = fs.readdirSync(uploadDir);
    const targetFile = files.find(file => file.includes(fileName.replace(/\.[^/.]+$/, "")));
    
    if (targetFile) {
      const filePath = path.join(uploadDir, targetFile);
      fs.unlinkSync(filePath);
      
      await sendSimpleLineMessage(userId, `üóëÔ∏è Ê™îÊ°à "${fileName}" Â∑≤ÊàêÂäüÂà™Èô§`);
      console.log('üóëÔ∏è Ê™îÊ°àÂ∑≤Âà™Èô§:', targetFile);
    } else {
      await sendSimpleLineMessage(userId, `‚ùå Êâæ‰∏çÂà∞Ê™îÊ°à "${fileName}"ÔºåÂèØËÉΩÂ∑≤Á∂ìË¢´Âà™Èô§`);
    }
    
  } catch (error) {
    console.error('‚ùå Âà™Èô§Ê™îÊ°àÈåØË™§:', error);
    await sendSimpleLineMessage(userId, `‚ùå Âà™Èô§Ê™îÊ°àÊôÇÁôºÁîüÈåØË™§Ôºö${error.message}`);
  }
}

// ===== API Ë∑ØÁî± =====

// ÂÅ•Â∫∑Ê™¢Êü•
app.get('/api/health', (req, res) => {
  console.log('‚ù§Ô∏è ÂÅ•Â∫∑Ê™¢Êü•');
  res.json({ 
    status: 'ok',
    timestamp: new Date().toISOString(),
    port: PORT,
    uploadDir: uploadDir,
    lineToken: process.env.LINE_CHANNEL_ACCESS_TOKEN ? 'Â∑≤Ë®≠ÂÆö' : 'Êú™Ë®≠ÂÆö'
  });
});

// Ê∏¨Ë©¶ API
app.get('/api/test', (req, res) => {
  console.log('üß™ Ê∏¨Ë©¶ API');
  res.json({ 
    message: '‰º∫ÊúçÂô®Ê≠£Â∏∏ÈÅã‰Ωú',
    timestamp: new Date().toISOString()
  });
});

// LINE Webhook ËôïÁêÜ PostBack ‰∫ã‰ª∂
app.post('/api/webhook', async (req, res) => {
  console.log('üì® Êî∂Âà∞ LINE Webhook:', JSON.stringify(req.body, null, 2));
  
  try {
    const events = req.body.events || [];
    
    for (const event of events) {
      if (event.type === 'postback') {
        console.log('üîÑ ËôïÁêÜ PostBack:', event.postback.data);
        
        const userId = event.source.userId;
        const postbackData = JSON.parse(event.postback.data);
        
        switch (postbackData.action) {
          case 'copy_link':
            await sendSimpleLineMessage(userId, 
              `üìã ‰∏ãËºâÈÄ£ÁµêÂ∑≤Ê∫ñÂÇôÂ•ΩÔºö\n\n${postbackData.url}\n\nÊ™îÊ°àÔºö${postbackData.fileName}\n\nÈï∑Êåâ‰∏äÊñπÈÄ£ÁµêÂèØË§áË£ΩÂà∞Ââ™Ë≤ºÁ∞ø`
            );
            break;
            
          case 'delete_file':
            if (postbackData.confirm) {
              await handleFileDelete(userId, postbackData.fileName);
            }
            break;
            
          default:
            console.log('‚ùì Êú™Áü•ÁöÑ PostBack Âãï‰Ωú:', postbackData.action);
        }
      }
    }
    
    res.status(200).json({ status: 'ok' });
    
  } catch (error) {
    console.error('‚ùå Webhook ËôïÁêÜÈåØË™§:', error);
    res.status(200).json({ status: 'error' }); // LINE ÈúÄË¶Å 200 ÂõûÊáâ
  }
});

// Ê™îÊ°à‰∏äÂÇ≥ API - ‰øÆÊîπÁâàÊú¨ÔºåÂä†ÂÖ•Ê®°Êì¨ PostBack
app.post('/api/upload', (req, res) => {
  console.log('üì§ ‰∏äÂÇ≥Ë´ãÊ±Ç');
  
  upload.single('file')(req, res, async (err) => {
    try {
      if (err) {
        console.error('‚ùå ‰∏äÂÇ≥ÈåØË™§:', err.message);
        return res.status(400).json({ 
          success: false, 
          error: err.message 
        });
      }

      if (!req.file) {
        return res.status(400).json({ 
          success: false, 
          error: 'Ê≤íÊúâÊî∂Âà∞Ê™îÊ°à' 
        });
      }

      console.log('‚úÖ Ê™îÊ°à‰∏äÂÇ≥ÊàêÂäü:', req.file.originalname);

      // Âª∫Á´ã‰∏ãËºâ URL
      const baseUrl = process.env.FRONTEND_URL || `http://localhost:${PORT}`;
      const downloadUrl = `${baseUrl}/api/download/${req.file.filename}`;

      const result = {
        success: true,
        fileName: req.file.originalname,
        savedName: req.file.filename,
        fileSize: req.file.size,
        downloadUrl: downloadUrl,
        uploadTime: new Date().toISOString()
      };

      // üé≠ Ê®°Êì¨Áî®Êà∂ÁôºÈÄÅ PostBack Âà∞ Webhook
      const userId = req.body.userId;
      if (userId) {
        console.log('üé≠ ÈñãÂßãÊ®°Êì¨Áî®Êà∂ PostBack');
        result.webhookSimulated = await simulateUserPostbackToWebhook(
          userId, 
          downloadUrl, 
          req.file.originalname, 
          req.file.size
        );
      }

      // ÂéüÊúâÁöÑ LINE Ë®äÊÅØÁôºÈÄÅÔºàÂèØÈÅ∏Ôºâ
      if (userId && process.env.LINE_CHANNEL_ACCESS_TOKEN && process.env.SEND_ORIGINAL_MESSAGE === 'true') {
        console.log('üì± ÁôºÈÄÅÂéüÊúâÁöÑ LINE Ë®äÊÅØ');
        result.lineSent = await sendLineDownloadMessage(
          userId, 
          req.file.originalname, 
          downloadUrl, 
          req.file.size
        );
      }

      res.json(result);

    } catch (error) {
      console.error('‚ùå ËôïÁêÜÈåØË™§:', error);
      res.status(500).json({ 
        success: false, 
        error: '‰º∫ÊúçÂô®ÈåØË™§' 
      });
    }
  });
});

// Ê™îÊ°à‰∏ãËºâ API
app.get('/api/download/:filename', (req, res) => {
  try {
    const filename = req.params.filename;
    const filePath = path.join(uploadDir, filename);
    
    console.log('üì• ‰∏ãËºâË´ãÊ±Ç:', filename);
    
    if (!fs.existsSync(filePath)) {
      console.log('‚ùå Ê™îÊ°à‰∏çÂ≠òÂú®:', filename);
      return res.status(404).json({ error: 'Ê™îÊ°à‰∏çÂ≠òÂú®' });
    }
    
    // Ë®≠ÂÆöÈÅ©Áï∂ÁöÑ Content-Type
    const ext = path.extname(filename).toLowerCase();
    let contentType = 'application/octet-stream';
    
    switch (ext) {
      case '.pdf':
        contentType = 'application/pdf';
        break;
      case '.doc':
        contentType = 'application/msword';
        break;
      case '.docx':
        contentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
        break;
    }
    
    // ÂèñÂæóÂéüÂßãÊ™îÂêçÔºàÂéªÊéâÊôÇÈñìÊà≥Ôºâ
    const originalName = filename.replace(/^\d+-/, '');
    
    res.setHeader('Content-Type', contentType);
    res.setHeader('Content-Disposition', `attachment; filename*=UTF-8''${encodeURIComponent(originalName)}`);
    res.setHeader('Access-Control-Expose-Headers', 'Content-Disposition');
    
    console.log('‚úÖ ÈñãÂßã‰∏ãËºâ:', originalName);
    res.sendFile(filePath);
    
  } catch (error) {
    console.error('‚ùå ‰∏ãËºâÈåØË™§:', error);
    res.status(500).json({ error: '‰∏ãËºâÂ§±Êïó' });
  }
});

// ÂàóÂá∫Ê™îÊ°à
app.get('/api/files', (req, res) => {
  try {
    if (!fs.existsSync(uploadDir)) {
      return res.json({ files: [] });
    }
    
    const files = fs.readdirSync(uploadDir).map(filename => {
      const filePath = path.join(uploadDir, filename);
      const stats = fs.statSync(filePath);
      const originalName = filename.replace(/^\d+-/, '');
      
      return {
        filename: originalName,
        savedName: filename,
        size: stats.size,
        uploadTime: stats.birthtime,
        downloadUrl: `/api/download/${filename}`
      };
    });
    
    res.json({ files });
  } catch (error) {
    console.error('‚ùå ÂàóÂá∫Ê™îÊ°àÈåØË™§:', error);
    res.status(500).json({ error: 'ÁÑ°Ê≥ïÂàóÂá∫Ê™îÊ°à' });
  }
});

// Ê∏¨Ë©¶Ê®°Êì¨ PostBack API
app.post('/api/simulate-postback', async (req, res) => {
  try {
    const { userId, fileName, downloadUrl, fileSize } = req.body;
    
    if (!userId) {
      return res.status(400).json({ error: 'ÈúÄË¶Å userId' });
    }
    
    console.log('üß™ ÊâãÂãïÊ∏¨Ë©¶Ê®°Êì¨ PostBack');
    
    const result = await simulateUserPostbackToWebhook(
      userId, 
      downloadUrl || 'https://example.com/test.pdf',
      fileName || 'test.pdf',
      fileSize || 1024000
    );
    
    res.json({ 
      success: result, 
      message: result ? 'Ê®°Êì¨ PostBack ÊàêÂäü' : 'Ê®°Êì¨ PostBack Â§±Êïó'
    });
    
  } catch (error) {
    console.error('‚ùå Ê∏¨Ë©¶Ê®°Êì¨ PostBack Â§±Êïó:', error);
    res.status(500).json({ error: error.message });
  }
});

// ÈùúÊÖãÊ™îÊ°àÊúçÂãôÔºà‰øùÁïôËàäÁöÑ uploads Ë∑ØÁî±‰ΩúÁÇ∫ÂÇôÁî®Ôºâ
app.use('/uploads', express.static(uploadDir));

// Êèê‰æõÂâçÁ´ØÊ™îÊ°à
app.use(express.static(__dirname));

// Ê†πË∑ØÁî±
app.get('/', (req, res) => {
  console.log('üè† Ê†πË∑ØÁî±Ë´ãÊ±Ç');
  res.sendFile(path.join(__dirname, 'index.html'));
});

// Catch-all Ë∑ØÁî±
app.get('*', (req, res) => {
  console.log('üîç Êú™ÂåπÈÖçË∑ØÁî±:', req.url);
  if (req.url.startsWith('/api/')) {
    res.status(404).json({ error: 'API Ë∑ØÁî±‰∏çÂ≠òÂú®' });
  } else {
    res.sendFile(path.join(__dirname, 'index.html'));
  }
});

// ÈåØË™§ËôïÁêÜ
app.use((err, req, res, next) => {
  console.error('‚ùå ÂÖ®ÂüüÈåØË™§:', err);
  res.status(500).json({ error: '‰º∫ÊúçÂô®ÈåØË™§' });
});

// ÂïüÂãï‰º∫ÊúçÂô®
const server = app.listen(PORT, '0.0.0.0', () => {
  console.log('üéâ ‰º∫ÊúçÂô®ÂïüÂãïÊàêÂäüÔºÅ');
  console.log(`üåê URL: http://localhost:${PORT}`);
  console.log(`üìÅ ‰∏äÂÇ≥ÁõÆÈåÑ: ${uploadDir}`);
  console.log(`üì± LINE Token: ${process.env.LINE_CHANNEL_ACCESS_TOKEN ? 'Â∑≤Ë®≠ÂÆö' : 'Êú™Ë®≠ÂÆö'}`);
  console.log(`üîó Webhook URL: ${process.env.FRONTEND_URL || 'http://localhost:' + PORT}/api/webhook`);
  console.log(`üé≠ Ê®°Êì¨ PostBack: Â∑≤ÂïüÁî®`);
  console.log('================================');
});

// ÂÑ™ÈõÖÈóúÈñâ
process.on('SIGTERM', () => {
  console.log('üì¥ Êî∂Âà∞ SIGTERMÔºåÊ≠£Âú®ÈóúÈñâ‰º∫ÊúçÂô®...');
  server.close(() => {
    console.log('‚úÖ ‰º∫ÊúçÂô®Â∑≤ÈóúÈñâ');
    process.exit(0);
  });
});
